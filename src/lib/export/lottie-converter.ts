// Lottie Animation Converter - Convert Typographer animations to Lottie format

import { WordData, MotionDirection } from '@/types/typographer'
import { TypographySettings } from '@/types/typography'
import { MotionSettings } from '@/types/motion'

export type AspectRatio = '16:9' | '9:16' | '1:1' | 'custom'

export interface ExportOptions {
  width?: number
  height?: number
  duration?: number
  framerate?: number
  aspectRatio?: AspectRatio
}

interface LottieAnimation {
  v: string // Lottie version
  fr: number // Framerate
  ip: number // In point (start frame)
  op: number // Out point (end frame)
  w: number // Width
  h: number // Height
  nm: string // Name
  ddd: number // 3D flag (0 = 2D)
  assets: any[]
  layers: LottieLayer[]
  markers?: any[]
  meta?: {
    a: string // Author
    k: string // Keywords
    d: string // Description
    tc: number // Time created
  }
}

interface LottieLayer {
  ddd: number // 3D flag
  ind: number // Index
  ty: number // Type (5 = text layer, 4 = shape layer)
  nm: string // Name
  sr: number // Stretch
  ks: LottieTransform // Transform properties
  ao: number // Auto-orient
  ip: number // In point
  op: number // Out point
  st: number // Start time
  bm: number // Blend mode
  t?: LottieTextData // Text data (for text layers)
  shapes?: LottieShapeElement[] // Shape data (for shape layers)
}

interface LottieTransform {
  a: LottieProperty<[number, number]> // Anchor point
  p: LottieProperty<[number, number]> // Position
  s: LottieProperty<[number, number]> // Scale
  r: LottieProperty<number> // Rotation
  o: LottieProperty<number> // Opacity
  sk?: LottieProperty<number> // Skew
  sa?: LottieProperty<number> // Skew Axis
}

interface LottieProperty<T> {
  a: number // Animated flag (0 = static, 1 = animated)
  k: T | LottieKeyframe<T>[] // Keyframes or static value
  ix?: number // Property index
}

interface LottieKeyframe<T> {
  i: { x: number[], y: number[] } // In tangent
  o: { x: number[], y: number[] } // Out tangent
  t: number // Time
  s: T[] // Start value
  e?: T[] // End value (optional for last keyframe)
}

interface LottieTextData {
  d: {
    k: LottieTextDocument[]
  }
  p: any // Path options
  m: any // More options
  a: any[] // Animators
}

interface LottieTextDocument {
  s: { // Style
    f: string // Font family
    fc: [number, number, number] // Fill color
    fs: number // Font size
    t: number // Tracking
    lh: number // Line height
    ls: number // Letter spacing
  }
  t: string // Text content
}

interface LottieShapeElement {
  ty: string // Type ('gr' = group, 'sh' = shape, 'fl' = fill, 'st' = stroke)
  nm: string // Name
  it?: LottieShapeElement[] // Items (for groups)
  ks?: LottieShapeKeyframes // Keyframes (for shapes)
  c?: LottieProperty<[number, number, number]> // Color (for fills/strokes)
  o?: LottieProperty<number> // Opacity
  w?: LottieProperty<number> // Width (for strokes)
  d?: LottieProperty<[number, number]> // Path data
}

interface LottieShapeKeyframes {
  a: number // Animated
  k: any // Keyframes or value
}

class LottieConverter {
  /**
   * Convert Typographer animation to Lottie format
   */
  convertToLottie(
    words: WordData[],
    typography: TypographySettings,
    motionSettings: MotionSettings,
    options: ExportOptions = {}
  ): LottieAnimation {
    console.log('convertToLottie called with:', { words, typography, motionSettings, options })
    
    // Ensure words is an array
    const wordsArray = Array.isArray(words) ? words : []
    
    if (wordsArray.length === 0) {
      console.warn('No words provided for Lottie conversion')
      // Return a basic empty animation instead of throwing
    }
    
    console.log('Processing words array:', wordsArray)

    // Calculate dimensions based on aspect ratio
    const { width, height } = this.calculateDimensions(options)
    const {
      duration = 10, // seconds
      framerate = 30
    } = options

    const totalFrames = duration * framerate

    // Create base Lottie animation structure
    const lottieAnimation: LottieAnimation = {
      v: "5.7.4", // Lottie version
      fr: framerate,
      ip: 0, // In point
      op: totalFrames, // Out point
      w: width,
      h: height,
      nm: "Typographer Animation",
      ddd: 0, // 2D animation
      assets: [],
      layers: [],
      markers: [],
      meta: {
        a: "Typographer",
        k: "text animation typography motion",
        d: "Generated by Typographer",
        tc: Date.now()
      }
    }

    // Add background layer if background color is not transparent
    if (typography.backgroundColor && typography.backgroundColor !== 'transparent') {
      const backgroundLayer = this.createBackgroundLayer(
        typography.backgroundColor,
        totalFrames,
        width,
        height
      )
      lottieAnimation.layers.push(backgroundLayer)
    }

    // Convert each word to a text layer
    const hasBackground = typography.backgroundColor && typography.backgroundColor !== 'transparent'
    wordsArray.forEach((word, index) => {
      const layer = this.createTextLayer(
        word,
        index + (hasBackground ? 1 : 0), // Offset index if background exists
        typography,
        motionSettings,
        totalFrames,
        width,
        height
      )
      lottieAnimation.layers.push(layer)
    })

    return lottieAnimation
  }

  /**
   * Create a background layer
   */
  private createBackgroundLayer(
    backgroundColor: string,
    totalFrames: number,
    width: number,
    height: number
  ): LottieLayer {
    const bgColor = this.hexToRgb(backgroundColor)
    
    return {
      ddd: 0,
      ind: 0, // Background layer gets index 0
      ty: 1, // Solid layer type
      nm: "Background",
      sr: 1,
      ks: {
        a: { a: 0, k: [0, 0], ix: 1 },
        p: { a: 0, k: [width / 2, height / 2], ix: 2 },
        s: { a: 0, k: [100, 100], ix: 3 },
        r: { a: 0, k: 0, ix: 4 },
        o: { a: 0, k: 100, ix: 5 }
      },
      ao: 0,
      ip: 0,
      op: totalFrames,
      st: 0,
      bm: 0,
      sc: backgroundColor.startsWith('#') ? backgroundColor : `#${backgroundColor}`, // Solid color
      sh: height,
      sw: width
    } as LottieLayer & { sc: string, sh: number, sw: number }
  }

  /**
   * Create a text layer for a word
   */
  private createTextLayer(
    word: WordData,
    index: number,
    typography: TypographySettings,
    motionSettings: MotionSettings,
    totalFrames: number,
    canvasWidth: number,
    canvasHeight: number
  ): LottieLayer {
    // Convert CSS color to RGB array
    const textColor = this.hexToRgb(typography.color)
    
    // Calculate timing based on motion settings and word index
    const wordDelay = (word.startDelay || 0) * totalFrames / 100
    const wordDuration = (word.duration || motionSettings.duration) * totalFrames / 100
    const startFrame = wordDelay
    const endFrame = Math.min(startFrame + wordDuration, totalFrames)

    // Create animated properties based on motion direction
    const animatedTransform = this.createAnimatedTransform(
      word,
      motionSettings,
      startFrame,
      endFrame,
      canvasWidth,
      canvasHeight
    )

    // Text layer
    const layer: LottieLayer = {
      ddd: 0,
      ind: index + 1, // Layer index
      ty: 5, // Text layer type
      nm: `Word ${index + 1}: ${word.text}`,
      sr: 1,
      ks: animatedTransform,
      ao: 0,
      ip: startFrame,
      op: endFrame,
      st: 0,
      bm: 0, // Normal blend mode
      t: {
        d: {
          k: [{
            s: {
              f: typography.fontFamily || "Arial",
              fc: textColor,
              fs: typography.fontSize || 48,
              t: 0, // Tracking
              lh: typography.lineHeight ? typography.lineHeight * (typography.fontSize || 48) : (typography.fontSize || 48) * 1.2,
              ls: typography.letterSpacing || 0
            },
            t: word.text
          }]
        },
        p: {}, // Path options
        m: {}, // More options
        a: [] // Animators for text animations
      }
    }

    return layer
  }

  /**
   * Create animated transform properties
   */
  private createAnimatedTransform(
    word: WordData,
    motionSettings: MotionSettings,
    startFrame: number,
    endFrame: number,
    canvasWidth: number,
    canvasHeight: number
  ): LottieTransform {
    const centerX = canvasWidth / 2
    const centerY = canvasHeight / 2

    // Calculate motion based on direction
    const { startPos, endPos } = this.calculateMotionPath(
      word.motionDirection || motionSettings.direction,
      centerX,
      centerY,
      canvasWidth,
      canvasHeight
    )

    // Create easing curve
    const easing = this.createEasingCurve(motionSettings.easing)

    return {
      a: { // Anchor point
        a: 0,
        k: [centerX / 2, centerY / 2], // Static anchor point
        ix: 1
      },
      p: { // Position
        a: 1, // Animated
        k: [
          {
            i: easing.i,
            o: easing.o,
            t: startFrame,
            s: [startPos.x, startPos.y],
            e: [endPos.x, endPos.y]
          },
          {
            i: { x: [0.833], y: [0.833] },
            o: { x: [0.167], y: [0.167] },
            t: endFrame,
            s: [endPos.x, endPos.y]
          }
        ],
        ix: 2
      },
      s: { // Scale
        a: 1, // Animated for entrance effect
        k: [
          {
            i: easing.i,
            o: easing.o,
            t: startFrame,
            s: [0, 0], // Start from zero scale
            e: [100, 100] // End at full scale
          },
          {
            i: { x: [0.833], y: [0.833] },
            o: { x: [0.167], y: [0.167] },
            t: endFrame,
            s: [100, 100]
          }
        ],
        ix: 3
      },
      r: { // Rotation
        a: 0,
        k: 0, // No rotation by default
        ix: 4
      },
      o: { // Opacity
        a: 1, // Animated
        k: [
          {
            i: { x: [0.833], y: [0.833] },
            o: { x: [0.167], y: [0.167] },
            t: startFrame,
            s: [0], // Start transparent
            e: [100] // End opaque
          },
          {
            i: { x: [0.833], y: [0.833] },
            o: { x: [0.167], y: [0.167] },
            t: endFrame - 10, // Start fading 10 frames before end
            s: [100],
            e: [0] // End transparent
          },
          {
            i: { x: [0.833], y: [0.833] },
            o: { x: [0.167], y: [0.167] },
            t: endFrame,
            s: [0]
          }
        ],
        ix: 5
      }
    }
  }

  /**
   * Calculate motion path based on direction
   */
  private calculateMotionPath(
    direction: MotionDirection,
    centerX: number,
    centerY: number,
    canvasWidth: number,
    canvasHeight: number
  ): { startPos: { x: number, y: number }, endPos: { x: number, y: number } } {
    const offset = Math.min(canvasWidth, canvasHeight) * 0.3

    switch (direction) {
      case 'left':
        return {
          startPos: { x: centerX - offset, y: centerY },
          endPos: { x: centerX, y: centerY }
        }
      case 'right':
        return {
          startPos: { x: centerX + offset, y: centerY },
          endPos: { x: centerX, y: centerY }
        }
      case 'up':
        return {
          startPos: { x: centerX, y: centerY - offset },
          endPos: { x: centerX, y: centerY }
        }
      case 'down':
        return {
          startPos: { x: centerX, y: centerY + offset },
          endPos: { x: centerX, y: centerY }
        }
      case 'fade':
      default:
        return {
          startPos: { x: centerX, y: centerY },
          endPos: { x: centerX, y: centerY }
        }
    }
  }

  /**
   * Create easing curve for Lottie
   */
  private createEasingCurve(easing: string): { i: { x: number[], y: number[] }, o: { x: number[], y: number[] } } {
    switch (easing) {
      case 'easeIn':
        return {
          i: { x: [0.42], y: [0] },
          o: { x: [1], y: [1] }
        }
      case 'easeOut':
        return {
          i: { x: [0], y: [0] },
          o: { x: [0.58], y: [1] }
        }
      case 'easeInOut':
        return {
          i: { x: [0.42], y: [0] },
          o: { x: [0.58], y: [1] }
        }
      case 'bounce':
        return {
          i: { x: [0.68], y: [-0.55] },
          o: { x: [0.265], y: [1.55] }
        }
      case 'elastic':
        return {
          i: { x: [0.25], y: [0.46] },
          o: { x: [0.45], y: [0.94] }
        }
      case 'linear':
      default:
        return {
          i: { x: [0.25], y: [0.25] },
          o: { x: [0.75], y: [0.75] }
        }
    }
  }

  /**
   * Convert hex color to RGB array
   */
  private hexToRgb(hex: string): [number, number, number] {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex)
    if (result) {
      return [
        parseInt(result[1], 16) / 255,
        parseInt(result[2], 16) / 255,
        parseInt(result[3], 16) / 255
      ]
    }
    return [0, 0, 0] // Default to black
  }

  /**
   * Calculate dimensions based on aspect ratio
   */
  calculateDimensions(options: ExportOptions): { width: number, height: number } {
    const { aspectRatio = '16:9', width: customWidth, height: customHeight } = options
    
    // If custom dimensions are provided, use them
    if (customWidth && customHeight) {
      return { width: customWidth, height: customHeight }
    }
    
    // Calculate based on aspect ratio with reasonable default sizes
    switch (aspectRatio) {
      case '16:9':
        return { width: 1920, height: 1080 }
      case '9:16':
        return { width: 1080, height: 1920 }
      case '1:1':
        return { width: 1080, height: 1080 }
      case 'custom':
        return { width: customWidth || 1920, height: customHeight || 1080 }
      default:
        return { width: 1920, height: 1080 }
    }
  }

  /**
   * Export Lottie animation as JSON string
   */
  exportLottieJson(
    words: WordData[],
    typography: TypographySettings,
    motionSettings: MotionSettings,
    options: ExportOptions = {}
  ): string {
    const lottieAnimation = this.convertToLottie(words, typography, motionSettings, options)
    return JSON.stringify(lottieAnimation, null, 2)
  }
}

// Export singleton instance
export const lottieConverter = new LottieConverter()